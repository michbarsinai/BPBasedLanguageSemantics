package org.b_prog.lscobpjv2.lsclang.syntax;

import java.util.Arrays;
import java.util.List;
import org.b_prog.lscobpjv2.lsclang.Modality;
import org.b_prog.lscobpjv2.lsclang.syntax.locations.MessageReceiveLocation;
import org.b_prog.lscobpjv2.lsclang.syntax.locations.MessageSendLocation;

/**
 * An LSC message, sent from one lifeline to another (they can also be the same, of course).
 * @author michael
 */
public class Message extends ModalLscConstruct {
    private final String methodName;
    private final List<Object> params;

    public Message(String methodName, Modality.Temperature temperature, Modality.Trigger trigger, Object... params) {
        super(temperature, trigger);
        this.methodName = methodName;
        this.params = Arrays.asList(params);
    }
    
    public boolean isUnifiable( Message other ) {
        // TODO complete this to support the full message unification spectrum, including 
        // symbolic lifelines and variables.
        
        return ( isUnifiable(getSendLocation().getLifeline(), other.getSendLocation().getLifeline())
                 && isUnifiable(getReceiveLocation().getLifeline(), other.getReceiveLocation().getLifeline())
                 && methodName.equals(other.getMethodName())
                 && params.equals(other.params) );
        
    }
    
    private boolean isUnifiable( Lifeline a, Lifeline b ) {
        // TODO expend to include symbolic lifelines
        return ( a.getId().equals(b.getId())
                    && a.getLscClass().equals(b.getLscClass()));
    }
    
    public MessageSendLocation getSendLocation() {
        return new MessageSendLocation(this);
    }
    
    public MessageReceiveLocation getReceiveLocation() {
        return new MessageReceiveLocation(this);
    }

    public String getMethodName() {
        return methodName;
    }

    public List<Object> getParams() {
        return params;
    }
    
   
}
